<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.Engine.obstacle_spawner API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.Engine.obstacle_spawner</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from Sprites.log import Log
from Sprites.car import Car
from Sprites.turtle import Turtle
from Sprites.turtle_animated import TurtleSinker
from Util.asset_dictionary import AssetDictionary


def sprite_despawner(sprite, win):
    x = sprite.rect.x
    y = sprite.rect.y

    if x + sprite.rect.width &lt; 0 or x &gt; win.get_width() + 1:
        sprite.kill()

    if y + sprite.rect.height &lt; 0 or y &gt; win.get_height() + 1:
        sprite.kill()


def spawn_water_lanes(framecount, lane1, lane2, lane3, lane4, lane5, log_turtle_groups, win):
    &#34;&#34;&#34;
    Called on every frame to handle spawning and animating water platforms. Param framecount should be the current
    frame being rendered. Params lane1 through lane5 should be the water lane sprite groups, each representing one
    lane starting from the bottom of the screen. So lane1 should be the group representing the lane of turtles
    closest to the road, and lane5 should be the lane of logs closest to the frog nests. Param log_turtle_groups
    should be a list of sprite groups that each log or turtle should be places in when it spawns. This should include
    at least the render group and the neural network group, though this can be expanded.

    - :param framecount:
        An int containing the current frame being rendered
    - :param lane1:
        A Group object containing all of the logs or turtles in a lane
    - :param lane2:
        A Group object containing all of the logs or turtles in a lane
    - :param lane3:
        A Group object containing all of the logs or turtles in a lane
    - :param lane4:
        A Group object containing all of the logs or turtles in a lane
    - :param lane5:
        A Group object containing all of the logs or turtles in a lane
    - :param log_turtle_groups:
        A list of sprite groups that each car should be places in when it spawns.
    - :param win:
        A pygame Surface object. This should be the top-level window object of the game.
    - :return:
        None
    &#34;&#34;&#34;

    # Spawns turtles in lane 1 every 2 seconds, spawning a sinking turtle every 4th spawn
    if framecount % 60 == 0:
        if framecount % 180 == 0:
            TurtleSinker(AssetDictionary.get_asset(&#34;triple-turtle-sink&#34;), framecount, 821, 372, 10).add(lane1, log_turtle_groups)
        else:
            Turtle(AssetDictionary.get_asset(&#34;triple-turtle&#34;), framecount, 821, 372).add(lane1, log_turtle_groups)

    # Spawns logs in lane 2 every 9 seconds, skipping every 4th spawn
    if framecount == 0 or (framecount % 270 == 0 and framecount % 1080 != 0):
        Log(AssetDictionary.get_asset(&#34;log-short&#34;), -999, 308).add(lane2, log_turtle_groups)

    # Spawns logs in lane 3 every 9 seconds
    if framecount % 90 == 0:
        Log(AssetDictionary.get_asset(&#34;log-long&#34;), -999, 244).add(lane3, log_turtle_groups)

    # Spawns turtles in lane 4 every 3 seconds, skipping every 5th spawn and sinking turtle every 6th
    if framecount % 90 == 0:
        if framecount % 540 == 0:
            TurtleSinker(AssetDictionary.get_asset(&#34;double-turtle-sink&#34;), framecount, 821, 180).add(lane4, log_turtle_groups)
        elif framecount % 450 != 0:
            Turtle(AssetDictionary.get_asset(&#34;double-turtle&#34;), framecount, 821, 180).add(lane4, log_turtle_groups)

    # Spawns logs in lane 5 every 5 seconds
    if framecount % 150 == 0:
        Log(AssetDictionary.get_asset(&#34;log-medium&#34;), -999, 116).add(lane5, log_turtle_groups)

    lane1_sprites = lane1.sprites()
    lane2_sprites = lane2.sprites()
    lane3_sprites = lane3.sprites()
    lane4_sprites = lane4.sprites()
    lane5_sprites = lane5.sprites()

    # Moves all entities in lane 1 at a constant speed and kill them if they have moved offscreen
    for sprite in lane1_sprites:
        sprite.rect.x -= 5
        sprite_despawner(sprite, win)

    # Moves all entities in lane 2 at a constant speed and kill them if they have moved offscreen
    for sprite in lane2_sprites:
        sprite.rect.x += 1
        sprite_despawner(sprite, win)

    # Moves all entities in lane 3 at a constant speed and kill them if they have moved offscreen
    for sprite in lane3_sprites:
        sprite.rect.x += 8
        sprite_despawner(sprite, win)

    # Moves all entities in lane 4 at a constant speed and kill them if they have moved offscreen
    for sprite in lane4_sprites:
        sprite.rect.x -= 4
        sprite_despawner(sprite, win)

    # Moves all entities in lane 5 at a constant speed and kill them if they have moved offscreen
    for sprite in lane5_sprites:
        sprite.rect.x += 3
        sprite_despawner(sprite, win)


def spawn_car_lanes(framecount, carlane1, carlane2, carlane3, carlane4, carlane5, car_groups, win):
    &#34;&#34;&#34;
    Called on every frame to handle spawning and animating car obstacles. Param framecount should be the current
    frame being rendered. Params lane1 through lane5 should be the car lane sprite groups, each representing one
    lane starting from the bottom of the screen. So lane1 should be the group representing the lane of cars closest
    bottom of the window, and lane5 should be the lane of cars closest to the water. Param car_groups should be a list
    of sprite groups that each car should be places in when it spawns. This should include at least the render group,
    the kill group, and the neural network group, though this can be expanded.

    - :param framecount:
        An int containing the current frame being rendered
    - :param carlane1:
        A Group object containing all of the cars in a lane
    - :param carlane2:
        A Group object containing all of the cars in a lane
    - :param carlane3:
        A Group object containing all of the cars in a lane
    - :param carlane4:
        A Group object containing all of the cars in a lane
    - :param carlane5:
        A Group object containing all of the cars in a lane
    - :param car_groups:
        A list of sprite groups that each car should be places in when it spawns.
    - :param win:
        A pygame Surface object. This should be the top-level window object of the game.
    - :return:
    &#34;&#34;&#34;
    # Spawns cars in lane 1 every 4 seconds, skipping every 4th spawn
    if framecount == 0 or (framecount % 120 == 0 and framecount % 360 != 0):
        Car(AssetDictionary.get_asset(&#34;car4&#34;), win.get_width() + 1, 750, win).add(carlane1, car_groups)

    # Spawns cars in lane 2 every 6 seconds, skipping every 4th spawn
    if framecount % 180 == 0 and framecount % 720 != 0:
        Car(AssetDictionary.get_asset(&#34;car3&#34;), 0 - AssetDictionary.asset_dict[&#34;car2&#34;].get_width(), 700,
            win).add(carlane2, car_groups)

    # Spawns cars in lane 3 every 4 seconds, skipping every 4th spawn
    if framecount == 0 or (framecount % 120 == 0 and framecount % 600 != 0):
        Car(AssetDictionary.get_asset(&#34;car2&#34;), win.get_width() + 1, 630, win).add(carlane3, car_groups)

    # Spawns cars in lane 4 every 10 seconds
    if framecount % 420 == 0:
        Car(AssetDictionary.get_asset(&#34;car1&#34;), 0 - AssetDictionary.asset_dict[&#34;car4&#34;].get_width(), 560,
            win).add(carlane4, car_groups)

    # Spawns cars in lane 5 every 3 seconds, skipping every 3rd spawn
    if framecount == 0 or (framecount % 90 == 0 and framecount % 270 != 0):
        Car(AssetDictionary.get_asset(&#34;semi-truck&#34;), win.get_width() + 1, 500, win).add(carlane5, car_groups)

    carlane1_sprites = carlane1.sprites()
    carlane2_sprites = carlane2.sprites()
    carlane3_sprites = carlane3.sprites()
    carlane4_sprites = carlane4.sprites()
    carlane5_sprites = carlane5.sprites()

    # Moves all cars in lane 1 at a constant speed and kill if go off screen
    for sprite in carlane1_sprites:
        sprite.rect.x += -2
        sprite_despawner(sprite, win)

    # Moves all cars in lane 2 at a constant speed and kill if go off screen
    for sprite in carlane2_sprites:
        sprite.rect.x += 2
        sprite_despawner(sprite, win)

    # Moves all cars in lane 3 at a constant speed and kill if go off screen
    for sprite in carlane3_sprites:
        sprite.rect.x += -3
        sprite_despawner(sprite, win)

    # Moves all cars in lane 4 at a constant speed and kill if go off screen
    for sprite in carlane4_sprites:
        sprite.rect.x += 3
        sprite_despawner(sprite, win)

    # Moves all cars in lane 5 at a constant speed and kill if go off screen
    for sprite in carlane5_sprites:
        sprite.rect.x += -4
        sprite_despawner(sprite, win)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.Engine.obstacle_spawner.spawn_car_lanes"><code class="name flex">
<span>def <span class="ident">spawn_car_lanes</span></span>(<span>framecount, carlane1, carlane2, carlane3, carlane4, carlane5, car_groups, win)</span>
</code></dt>
<dd>
<div class="desc"><p>Called on every frame to handle spawning and animating car obstacles. Param framecount should be the current
frame being rendered. Params lane1 through lane5 should be the car lane sprite groups, each representing one
lane starting from the bottom of the screen. So lane1 should be the group representing the lane of cars closest
bottom of the window, and lane5 should be the lane of cars closest to the water. Param car_groups should be a list
of sprite groups that each car should be places in when it spawns. This should include at least the render group,
the kill group, and the neural network group, though this can be expanded.</p>
<ul>
<li>:param framecount:
An int containing the current frame being rendered</li>
<li>:param carlane1:
A Group object containing all of the cars in a lane</li>
<li>:param carlane2:
A Group object containing all of the cars in a lane</li>
<li>:param carlane3:
A Group object containing all of the cars in a lane</li>
<li>:param carlane4:
A Group object containing all of the cars in a lane</li>
<li>:param carlane5:
A Group object containing all of the cars in a lane</li>
<li>:param car_groups:
A list of sprite groups that each car should be places in when it spawns.</li>
<li>:param win:
A pygame Surface object. This should be the top-level window object of the game.</li>
<li>:return:</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spawn_car_lanes(framecount, carlane1, carlane2, carlane3, carlane4, carlane5, car_groups, win):
    &#34;&#34;&#34;
    Called on every frame to handle spawning and animating car obstacles. Param framecount should be the current
    frame being rendered. Params lane1 through lane5 should be the car lane sprite groups, each representing one
    lane starting from the bottom of the screen. So lane1 should be the group representing the lane of cars closest
    bottom of the window, and lane5 should be the lane of cars closest to the water. Param car_groups should be a list
    of sprite groups that each car should be places in when it spawns. This should include at least the render group,
    the kill group, and the neural network group, though this can be expanded.

    - :param framecount:
        An int containing the current frame being rendered
    - :param carlane1:
        A Group object containing all of the cars in a lane
    - :param carlane2:
        A Group object containing all of the cars in a lane
    - :param carlane3:
        A Group object containing all of the cars in a lane
    - :param carlane4:
        A Group object containing all of the cars in a lane
    - :param carlane5:
        A Group object containing all of the cars in a lane
    - :param car_groups:
        A list of sprite groups that each car should be places in when it spawns.
    - :param win:
        A pygame Surface object. This should be the top-level window object of the game.
    - :return:
    &#34;&#34;&#34;
    # Spawns cars in lane 1 every 4 seconds, skipping every 4th spawn
    if framecount == 0 or (framecount % 120 == 0 and framecount % 360 != 0):
        Car(AssetDictionary.get_asset(&#34;car4&#34;), win.get_width() + 1, 750, win).add(carlane1, car_groups)

    # Spawns cars in lane 2 every 6 seconds, skipping every 4th spawn
    if framecount % 180 == 0 and framecount % 720 != 0:
        Car(AssetDictionary.get_asset(&#34;car3&#34;), 0 - AssetDictionary.asset_dict[&#34;car2&#34;].get_width(), 700,
            win).add(carlane2, car_groups)

    # Spawns cars in lane 3 every 4 seconds, skipping every 4th spawn
    if framecount == 0 or (framecount % 120 == 0 and framecount % 600 != 0):
        Car(AssetDictionary.get_asset(&#34;car2&#34;), win.get_width() + 1, 630, win).add(carlane3, car_groups)

    # Spawns cars in lane 4 every 10 seconds
    if framecount % 420 == 0:
        Car(AssetDictionary.get_asset(&#34;car1&#34;), 0 - AssetDictionary.asset_dict[&#34;car4&#34;].get_width(), 560,
            win).add(carlane4, car_groups)

    # Spawns cars in lane 5 every 3 seconds, skipping every 3rd spawn
    if framecount == 0 or (framecount % 90 == 0 and framecount % 270 != 0):
        Car(AssetDictionary.get_asset(&#34;semi-truck&#34;), win.get_width() + 1, 500, win).add(carlane5, car_groups)

    carlane1_sprites = carlane1.sprites()
    carlane2_sprites = carlane2.sprites()
    carlane3_sprites = carlane3.sprites()
    carlane4_sprites = carlane4.sprites()
    carlane5_sprites = carlane5.sprites()

    # Moves all cars in lane 1 at a constant speed and kill if go off screen
    for sprite in carlane1_sprites:
        sprite.rect.x += -2
        sprite_despawner(sprite, win)

    # Moves all cars in lane 2 at a constant speed and kill if go off screen
    for sprite in carlane2_sprites:
        sprite.rect.x += 2
        sprite_despawner(sprite, win)

    # Moves all cars in lane 3 at a constant speed and kill if go off screen
    for sprite in carlane3_sprites:
        sprite.rect.x += -3
        sprite_despawner(sprite, win)

    # Moves all cars in lane 4 at a constant speed and kill if go off screen
    for sprite in carlane4_sprites:
        sprite.rect.x += 3
        sprite_despawner(sprite, win)

    # Moves all cars in lane 5 at a constant speed and kill if go off screen
    for sprite in carlane5_sprites:
        sprite.rect.x += -4
        sprite_despawner(sprite, win)</code></pre>
</details>
</dd>
<dt id="src.Engine.obstacle_spawner.spawn_water_lanes"><code class="name flex">
<span>def <span class="ident">spawn_water_lanes</span></span>(<span>framecount, lane1, lane2, lane3, lane4, lane5, log_turtle_groups, win)</span>
</code></dt>
<dd>
<div class="desc"><p>Called on every frame to handle spawning and animating water platforms. Param framecount should be the current
frame being rendered. Params lane1 through lane5 should be the water lane sprite groups, each representing one
lane starting from the bottom of the screen. So lane1 should be the group representing the lane of turtles
closest to the road, and lane5 should be the lane of logs closest to the frog nests. Param log_turtle_groups
should be a list of sprite groups that each log or turtle should be places in when it spawns. This should include
at least the render group and the neural network group, though this can be expanded.</p>
<ul>
<li>:param framecount:
An int containing the current frame being rendered</li>
<li>:param lane1:
A Group object containing all of the logs or turtles in a lane</li>
<li>:param lane2:
A Group object containing all of the logs or turtles in a lane</li>
<li>:param lane3:
A Group object containing all of the logs or turtles in a lane</li>
<li>:param lane4:
A Group object containing all of the logs or turtles in a lane</li>
<li>:param lane5:
A Group object containing all of the logs or turtles in a lane</li>
<li>:param log_turtle_groups:
A list of sprite groups that each car should be places in when it spawns.</li>
<li>:param win:
A pygame Surface object. This should be the top-level window object of the game.</li>
<li>:return:
None</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spawn_water_lanes(framecount, lane1, lane2, lane3, lane4, lane5, log_turtle_groups, win):
    &#34;&#34;&#34;
    Called on every frame to handle spawning and animating water platforms. Param framecount should be the current
    frame being rendered. Params lane1 through lane5 should be the water lane sprite groups, each representing one
    lane starting from the bottom of the screen. So lane1 should be the group representing the lane of turtles
    closest to the road, and lane5 should be the lane of logs closest to the frog nests. Param log_turtle_groups
    should be a list of sprite groups that each log or turtle should be places in when it spawns. This should include
    at least the render group and the neural network group, though this can be expanded.

    - :param framecount:
        An int containing the current frame being rendered
    - :param lane1:
        A Group object containing all of the logs or turtles in a lane
    - :param lane2:
        A Group object containing all of the logs or turtles in a lane
    - :param lane3:
        A Group object containing all of the logs or turtles in a lane
    - :param lane4:
        A Group object containing all of the logs or turtles in a lane
    - :param lane5:
        A Group object containing all of the logs or turtles in a lane
    - :param log_turtle_groups:
        A list of sprite groups that each car should be places in when it spawns.
    - :param win:
        A pygame Surface object. This should be the top-level window object of the game.
    - :return:
        None
    &#34;&#34;&#34;

    # Spawns turtles in lane 1 every 2 seconds, spawning a sinking turtle every 4th spawn
    if framecount % 60 == 0:
        if framecount % 180 == 0:
            TurtleSinker(AssetDictionary.get_asset(&#34;triple-turtle-sink&#34;), framecount, 821, 372, 10).add(lane1, log_turtle_groups)
        else:
            Turtle(AssetDictionary.get_asset(&#34;triple-turtle&#34;), framecount, 821, 372).add(lane1, log_turtle_groups)

    # Spawns logs in lane 2 every 9 seconds, skipping every 4th spawn
    if framecount == 0 or (framecount % 270 == 0 and framecount % 1080 != 0):
        Log(AssetDictionary.get_asset(&#34;log-short&#34;), -999, 308).add(lane2, log_turtle_groups)

    # Spawns logs in lane 3 every 9 seconds
    if framecount % 90 == 0:
        Log(AssetDictionary.get_asset(&#34;log-long&#34;), -999, 244).add(lane3, log_turtle_groups)

    # Spawns turtles in lane 4 every 3 seconds, skipping every 5th spawn and sinking turtle every 6th
    if framecount % 90 == 0:
        if framecount % 540 == 0:
            TurtleSinker(AssetDictionary.get_asset(&#34;double-turtle-sink&#34;), framecount, 821, 180).add(lane4, log_turtle_groups)
        elif framecount % 450 != 0:
            Turtle(AssetDictionary.get_asset(&#34;double-turtle&#34;), framecount, 821, 180).add(lane4, log_turtle_groups)

    # Spawns logs in lane 5 every 5 seconds
    if framecount % 150 == 0:
        Log(AssetDictionary.get_asset(&#34;log-medium&#34;), -999, 116).add(lane5, log_turtle_groups)

    lane1_sprites = lane1.sprites()
    lane2_sprites = lane2.sprites()
    lane3_sprites = lane3.sprites()
    lane4_sprites = lane4.sprites()
    lane5_sprites = lane5.sprites()

    # Moves all entities in lane 1 at a constant speed and kill them if they have moved offscreen
    for sprite in lane1_sprites:
        sprite.rect.x -= 5
        sprite_despawner(sprite, win)

    # Moves all entities in lane 2 at a constant speed and kill them if they have moved offscreen
    for sprite in lane2_sprites:
        sprite.rect.x += 1
        sprite_despawner(sprite, win)

    # Moves all entities in lane 3 at a constant speed and kill them if they have moved offscreen
    for sprite in lane3_sprites:
        sprite.rect.x += 8
        sprite_despawner(sprite, win)

    # Moves all entities in lane 4 at a constant speed and kill them if they have moved offscreen
    for sprite in lane4_sprites:
        sprite.rect.x -= 4
        sprite_despawner(sprite, win)

    # Moves all entities in lane 5 at a constant speed and kill them if they have moved offscreen
    for sprite in lane5_sprites:
        sprite.rect.x += 3
        sprite_despawner(sprite, win)</code></pre>
</details>
</dd>
<dt id="src.Engine.obstacle_spawner.sprite_despawner"><code class="name flex">
<span>def <span class="ident">sprite_despawner</span></span>(<span>sprite, win)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sprite_despawner(sprite, win):
    x = sprite.rect.x
    y = sprite.rect.y

    if x + sprite.rect.width &lt; 0 or x &gt; win.get_width() + 1:
        sprite.kill()

    if y + sprite.rect.height &lt; 0 or y &gt; win.get_height() + 1:
        sprite.kill()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.Engine" href="index.html">src.Engine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.Engine.obstacle_spawner.spawn_car_lanes" href="#src.Engine.obstacle_spawner.spawn_car_lanes">spawn_car_lanes</a></code></li>
<li><code><a title="src.Engine.obstacle_spawner.spawn_water_lanes" href="#src.Engine.obstacle_spawner.spawn_water_lanes">spawn_water_lanes</a></code></li>
<li><code><a title="src.Engine.obstacle_spawner.sprite_despawner" href="#src.Engine.obstacle_spawner.sprite_despawner">sprite_despawner</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>