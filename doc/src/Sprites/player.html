<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.Sprites.player API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.Sprites.player</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pygame.sprite
import pygame.surface
from Util.window import Window
from Util.asset_dictionary import AssetDictionary


class Player(pygame.sprite.Sprite):
    &#34;&#34;&#34;
    Pygame sprite class representing the player. Constructor should be passed a pygame LayeredUpdates object to
    which the Player object will be added. By default, this class will get the list of image assets used for animating
    the frog&#39;s jump, but a different list of two image assets can be passed. The frog will animate between these
    two images when the player (not the AI) moves the frog.
    &#34;&#34;&#34;

    def __init__(self, render_group, images=AssetDictionary.get_asset(&#34;player&#34;)):
        &#34;&#34;&#34;
        - :param render_group:
            The pygame Group object containing all of the sprites to be rendered on the current frame
        - :param images:
            Optional. A list of image assets between which the sprite will animate when a human player moves the frog.
            Defaults to the &#34;player&#34; image asset found in the asset dictionary in utilities.
        &#34;&#34;&#34;
        pygame.sprite.Sprite.__init__(self)
        self.images = images
        self.rect = self.images[0].get_rect()
        self.rect.x = Window.WIN.get_width() / 2
        self.rect.y = Window.WIN.get_height() - self.rect.height - 11
        self.index = 0
        self.image = images[self.index]
        self.direction = &#34;up&#34;
        self.score = 0
        self.farthest_distance = 813
        self.lives_left = 6
        self.add(render_group)
        render_group.change_layer(self, 1)
        self.can_move = True
        self.x_vel = AssetDictionary.get_asset(&#34;frog&#34;).get_width() + 4
        self.y_vel = AssetDictionary.get_asset(&#34;frog&#34;).get_height() + 12
        self.last_advancement = 0
        self.on_sinking_turtle = False
        self.disabled_nests = pygame.sprite.Group()

    def nest(self, timer, nest):
        &#34;&#34;&#34;
        Called when the player reaches a nest to return him home and handle the score increase.

        - :param timer:
            An int representing the current timer value.
        - :param nest:
            A Nest object, should be the nest that the player reached to trigger this method to be called
        - :return:
            None
        &#34;&#34;&#34;
        if self.disabled_nests.has(nest):
            self.kill()
        else:
            self.return_home()
            self.farthest_distance = 813
            self.score += (50 + 2*timer)
            # pygame.time.set_timer(pygame.USEREVENT, 0)  # Reset clock tick so we aren&#39;t still using the old clock
            # pygame.time.set_timer(pygame.USEREVENT, 1000)
            # timer = 30
        if not self.disabled_nests.has(nest):
            self.disabled_nests.add(nest)

    def win_game(self):
        &#34;&#34;&#34;
        Called when the player reaches all nests and has won the game. Adds 2000 to the player&#39;s score and removes them
        from all groups they are in so they will no longer be rendered.

        - :return:
            None
        &#34;&#34;&#34;
        self.score += 2000
        for group in self.groups():
            self.remove(group)
        # quit_game(self)

    def kill(self):
        &#34;&#34;&#34;
        Called when the player dies. Returns him home, and subtracts a life from his life_count.

        - :return:
            None
        &#34;&#34;&#34;
        self.return_home()
        self.lives_left -= 1

        # if self.lives_left &lt; 0:
        #     print(&#34;player final score: &#34; + str(self.score))
        #     quit_game(self)

    def return_home(self):
        &#34;&#34;&#34;
        Return the player to the starting position, with the starting sprite orientation.

        - :return:
            None
        &#34;&#34;&#34;
        self.rect.x = Window.WIN.get_width() / 2
        self.rect.y = Window.WIN.get_height() - self.rect.height - 11
        self.index = 0
        self.image = self.images[self.index]
        self.direction = &#34;up&#34;
        up_image = AssetDictionary.get_asset(&#34;frog&#34;)
        up_image2 = AssetDictionary.get_asset(&#34;frog_jumping&#34;)
        self.images = [up_image, up_image2]

    def set_score(self):
        &#34;&#34;&#34;
        Called on every frame. Handles the logic determining when the player should receive more points for moving.

        - :return:
            None
        &#34;&#34;&#34;
        self.score += 0.01  # Reward the AI a little bit for staying alive another frame

        # If the current position is a new farthest distance, increase the score
        if self.farthest_distance &gt; self.rect.y &gt; 110:
            self.farthest_distance = self.rect.y
            self.score += 10
            if self.score &gt; 60 and self.rect.y &gt;= 109:
                self.score += 10

    def move(self, key_pressed, frame_count):
        &#34;&#34;&#34;
        Called when the AI computes an output layer. Takes a string containing w, a, s, or d, and moves the player
        in the corresponding direction. If any other input is passed, the player won&#39;t move at all.

        - :param key_pressed:
            A string that should contain w, a, s, or d corresponding to the desired direction to move. Anything else
            causes the player to do nothing.
        - :param frame_count:
            An int representing the current frame count of the game.
        - :return:
            None
        &#34;&#34;&#34;
        if key_pressed == &#34;w&#34; and self.rect.y &gt; 60:
            self.rect.y -= self.y_vel
            self.last_advancement = frame_count
        elif key_pressed == &#34;s&#34; and self.rect.y &lt; 800:
            self.rect.y += self.y_vel
        elif key_pressed == &#34;a&#34; and self.rect.x &gt; 20:
            self.rect.x -= self.x_vel
        elif key_pressed == &#34;d&#34; and self.rect.x &lt; 750:
            self.rect.x += self.x_vel
        else:
            return

    def find_distance_to_sprite(self, direction, sprites, player_lines=[]):
        &#34;&#34;&#34;
        Find the distance to the nearest sprite in a given direction. Calculates from the center point of the
        player to the sprite.rect.x or sprite.rect.y coordinate of the nearest sprite. Whether x or y is used depends
        on whether the direction being computed is vertical or horizontal - y for up or down and x for left or right.
        Parameter direction should be a string containing &#39;ahead&#39;, &#39;down&#39;, &#39;left&#39;, or &#39;right&#39; indicating the
        direction we wish to scan. Sprites should be a list of all the sprites that we want to &#39;see&#39;, which will be
        iterated over to scan for a sprite in the given direction. The player_lines parameter can be used to draw
        lines to the sprite for debugging, but defaults to empty.

        - :param direction:
            A string containing the direction to be searched. Should be &#34;ahead&#34;, &#34;down&#34;, &#34;left&#34;, or &#34;right&#34;. Anything else,
            and the function will return nothing.
        - :param sprites:
            A pygame Group object containing the sprites to be searched. Should be the Group object used for the AI to &#34;see&#34;
            other sprites.
        - :param player_lines:
            Optional debugging parameter. A list of tuples representing the endpoints of a line. This can be appended to
            in order to render the collision lines for debugging purposes.
        - :return:
            None
        &#34;&#34;&#34;
        # Player&#39;s current position will be the start point of a line that is used to check the nearest sprite
        player_x = self.rect.center[0]
        player_y = self.rect.center[1]
        player_pos = (player_x, player_y)

        if direction == &#34;ahead&#34;:
            distance_to_nearest = player_y

            # Set the endpoint of the line to the top of the screen, in the same x position as the player
            endpoint = (player_x, 0)

            # Iterate over the sprites we&#39;re concerned about to see if the line intersects
            for sprite in sprites:
                clipline = sprite.rect.clipline(player_pos, endpoint)

                # If the line intersects with the sprite in question, and the distance to it is shorter than current,
                # update current distance
                if clipline and player_y - sprite.rect.y &lt;= distance_to_nearest:
                    distance_to_nearest = player_y - sprite.rect.y

            return distance_to_nearest

        if direction == &#34;down&#34;:
            distance_to_nearest = Window.HEIGHT - player_y

            # Set the endpoint of the line to the bottom of the screen, in the same x position as the player
            endpoint = (player_x, Window.HEIGHT)

            # Iterate over the sprites we&#39;re concerned about to see if the line intersects
            for sprite in sprites:
                clipline = sprite.rect.clipline(player_pos, endpoint)

                # If the line intersects with the sprite in question, and the distance to it is shorter than current,
                # update current distance
                if clipline and sprite.rect.y - player_y &lt;= distance_to_nearest:
                    distance_to_nearest = sprite.rect.y - player_y

            return distance_to_nearest

        if direction == &#34;left&#34;:
            distance_to_nearest = player_x

            # Set the endpoint of the line to the left of the screen, in the same y position as the player
            endpoint = (0, player_y)

            # Iterate over the sprites we&#39;re concerned about to see if the line intersects
            for sprite in sprites.sprites():
                clipline = sprite.rect.clipline(player_pos, endpoint)

                # If the line intersects with the sprite in question, and the distance to it is shorter than current,
                # update current distance
                if clipline and player_x - (sprite.rect.x + sprite.rect.width) &lt;= distance_to_nearest:
                    distance_to_nearest = player_x - (sprite.rect.x + sprite.rect.width)

            return distance_to_nearest

        if direction == &#34;right&#34;:
            distance_to_nearest = Window.WIDTH - player_x

            # Set the endpoint of the line to the right of the screen, in the same y position as the player
            endpoint = (Window.WIDTH, player_y)

            # Iterate over the sprites we&#39;re concerned about to see if the line intersects
            for sprite in sprites.sprites():
                clipline = sprite.rect.clipline(player_pos, endpoint)

                # If the line intersects with the sprite in question, and the distance to it is shorter than current,
                # update current distance
                if clipline and sprite.rect.x - player_x &lt;= distance_to_nearest:
                    distance_to_nearest = sprite.rect.x - player_x

            return distance_to_nearest

    def find_sprite_in_next_lane(self, direction, sprites, player_lines=[]):
        &#34;&#34;&#34;
        Find the distance to the nearest sprite in the lane ahead or the lane behind the player. Returns a tuple
        containing the distance in the corresponding lane to the edge of the closest sprite on the left,
        and the closest sprite on the right, respectively. These distances will be measured from the x position of the
        center of the player rect.

        - :param direction:
            A string indicating whether the lane ahead is being searched or the lane behind. Should be &#34;ahead&#34; or &#34;down&#34;.
            Anything else, and the method won&#39;t return anything.
        - :param sprites:
            A pygame Group object containing the sprites to be searched. Should be the Group object used for the AI to &#34;see&#34;
            other sprites.
        - :param player_lines:
            Optional debugging parameter. A list of tuples representing the endpoints of a line. This can be appended to
            in order to render the collision lines for debugging purposes.
        - :return:
            None
        &#34;&#34;&#34;

        startpoint_x = self.rect.center[0]

        if direction == &#34;ahead&#34;:
            # If we want to use the lane ahead,
            # set the start point of the line to be one lane position ahead of the player
            startpoint_y = self.rect.center[1] - 64
            startpoint_pos = (startpoint_x, startpoint_y)

            # Initial distance is the distance to the left and right edges of the screen
            distance_to_left = startpoint_x
            distance_to_right = Window.WIDTH - startpoint_x

            # Set the endpoint of the left line and the right line to the edges of the screen
            left_endpoint = (0, startpoint_y)
            right_endpoint = (Window.WIDTH, startpoint_y)

            # Iterate over the sprites we&#39;re concerned about to see if the lines intersect
            for sprite in sprites.sprites():
                # Check the left side
                clipline = sprite.rect.clipline(startpoint_pos, left_endpoint)

                # If the line intersects with the sprite in question, and the distance to it is shorter than current,
                # update current distance
                if clipline and startpoint_x - (sprite.rect.x + sprite.rect.width) &lt;= distance_to_left:
                    distance_to_left = startpoint_x - (sprite.rect.x + sprite.rect.width)

                # Check the right side
                clipline = sprite.rect.clipline(startpoint_pos, right_endpoint)

                if clipline and sprite.rect.x - startpoint_x &lt;= distance_to_right:
                    distance_to_right = sprite.rect.x - startpoint_x

            # render lines for debugging
            # player_lines.append((startpoint_pos, (startpoint_x - distance_to_left, startpoint_y)))
            # player_lines.append((startpoint_pos, (startpoint_x + distance_to_right, startpoint_y)))
            return distance_to_left, distance_to_right

        if direction == &#34;down&#34;:
            # If we want to use the lane behind,
            # set the start point of the line to be one lane position behind the player
            startpoint_y = self.rect.center[1] + 64
            startpoint_pos = (startpoint_x, startpoint_y)

            # Initial distance is the distance to the left and right edges of the screen
            distance_to_left = startpoint_x
            distance_to_right = Window.WIDTH - startpoint_x

            # Set the endpoint of the left line and the right line to the edges of the screen
            left_endpoint = (0, startpoint_y)
            right_endpoint = (Window.WIDTH, startpoint_y)

            # Iterate over the sprites we&#39;re concerned about to see if the lines intersect
            for sprite in sprites.sprites():
                # Check the left side
                clipline = sprite.rect.clipline(startpoint_pos, left_endpoint)

                # If the line intersects with the sprite in question, and the distance to it is shorter than current,
                # update current distance
                if clipline and startpoint_x - (sprite.rect.x + sprite.rect.width) &lt;= distance_to_left:
                    distance_to_left = startpoint_x - (sprite.rect.x + sprite.rect.width)

                # Check the right side
                clipline = sprite.rect.clipline(startpoint_pos, right_endpoint)

                if clipline and sprite.rect.x - startpoint_x &lt;= distance_to_right:
                    distance_to_right = sprite.rect.x - startpoint_x

            return distance_to_left, distance_to_right</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.Sprites.player.Player"><code class="flex name class">
<span>class <span class="ident">Player</span></span>
<span>(</span><span>render_group, images=[&lt;Surface(64x52x32 SW)&gt;, &lt;Surface(64x60x32 SW)&gt;])</span>
</code></dt>
<dd>
<div class="desc"><p>Pygame sprite class representing the player. Constructor should be passed a pygame LayeredUpdates object to
which the Player object will be added. By default, this class will get the list of image assets used for animating
the frog's jump, but a different list of two image assets can be passed. The frog will animate between these
two images when the player (not the AI) moves the frog.</p>
<ul>
<li>:param render_group:
The pygame Group object containing all of the sprites to be rendered on the current frame</li>
<li>:param images:
Optional. A list of image assets between which the sprite will animate when a human player moves the frog.
Defaults to the "player" image asset found in the asset dictionary in utilities.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Player(pygame.sprite.Sprite):
    &#34;&#34;&#34;
    Pygame sprite class representing the player. Constructor should be passed a pygame LayeredUpdates object to
    which the Player object will be added. By default, this class will get the list of image assets used for animating
    the frog&#39;s jump, but a different list of two image assets can be passed. The frog will animate between these
    two images when the player (not the AI) moves the frog.
    &#34;&#34;&#34;

    def __init__(self, render_group, images=AssetDictionary.get_asset(&#34;player&#34;)):
        &#34;&#34;&#34;
        - :param render_group:
            The pygame Group object containing all of the sprites to be rendered on the current frame
        - :param images:
            Optional. A list of image assets between which the sprite will animate when a human player moves the frog.
            Defaults to the &#34;player&#34; image asset found in the asset dictionary in utilities.
        &#34;&#34;&#34;
        pygame.sprite.Sprite.__init__(self)
        self.images = images
        self.rect = self.images[0].get_rect()
        self.rect.x = Window.WIN.get_width() / 2
        self.rect.y = Window.WIN.get_height() - self.rect.height - 11
        self.index = 0
        self.image = images[self.index]
        self.direction = &#34;up&#34;
        self.score = 0
        self.farthest_distance = 813
        self.lives_left = 6
        self.add(render_group)
        render_group.change_layer(self, 1)
        self.can_move = True
        self.x_vel = AssetDictionary.get_asset(&#34;frog&#34;).get_width() + 4
        self.y_vel = AssetDictionary.get_asset(&#34;frog&#34;).get_height() + 12
        self.last_advancement = 0
        self.on_sinking_turtle = False
        self.disabled_nests = pygame.sprite.Group()

    def nest(self, timer, nest):
        &#34;&#34;&#34;
        Called when the player reaches a nest to return him home and handle the score increase.

        - :param timer:
            An int representing the current timer value.
        - :param nest:
            A Nest object, should be the nest that the player reached to trigger this method to be called
        - :return:
            None
        &#34;&#34;&#34;
        if self.disabled_nests.has(nest):
            self.kill()
        else:
            self.return_home()
            self.farthest_distance = 813
            self.score += (50 + 2*timer)
            # pygame.time.set_timer(pygame.USEREVENT, 0)  # Reset clock tick so we aren&#39;t still using the old clock
            # pygame.time.set_timer(pygame.USEREVENT, 1000)
            # timer = 30
        if not self.disabled_nests.has(nest):
            self.disabled_nests.add(nest)

    def win_game(self):
        &#34;&#34;&#34;
        Called when the player reaches all nests and has won the game. Adds 2000 to the player&#39;s score and removes them
        from all groups they are in so they will no longer be rendered.

        - :return:
            None
        &#34;&#34;&#34;
        self.score += 2000
        for group in self.groups():
            self.remove(group)
        # quit_game(self)

    def kill(self):
        &#34;&#34;&#34;
        Called when the player dies. Returns him home, and subtracts a life from his life_count.

        - :return:
            None
        &#34;&#34;&#34;
        self.return_home()
        self.lives_left -= 1

        # if self.lives_left &lt; 0:
        #     print(&#34;player final score: &#34; + str(self.score))
        #     quit_game(self)

    def return_home(self):
        &#34;&#34;&#34;
        Return the player to the starting position, with the starting sprite orientation.

        - :return:
            None
        &#34;&#34;&#34;
        self.rect.x = Window.WIN.get_width() / 2
        self.rect.y = Window.WIN.get_height() - self.rect.height - 11
        self.index = 0
        self.image = self.images[self.index]
        self.direction = &#34;up&#34;
        up_image = AssetDictionary.get_asset(&#34;frog&#34;)
        up_image2 = AssetDictionary.get_asset(&#34;frog_jumping&#34;)
        self.images = [up_image, up_image2]

    def set_score(self):
        &#34;&#34;&#34;
        Called on every frame. Handles the logic determining when the player should receive more points for moving.

        - :return:
            None
        &#34;&#34;&#34;
        self.score += 0.01  # Reward the AI a little bit for staying alive another frame

        # If the current position is a new farthest distance, increase the score
        if self.farthest_distance &gt; self.rect.y &gt; 110:
            self.farthest_distance = self.rect.y
            self.score += 10
            if self.score &gt; 60 and self.rect.y &gt;= 109:
                self.score += 10

    def move(self, key_pressed, frame_count):
        &#34;&#34;&#34;
        Called when the AI computes an output layer. Takes a string containing w, a, s, or d, and moves the player
        in the corresponding direction. If any other input is passed, the player won&#39;t move at all.

        - :param key_pressed:
            A string that should contain w, a, s, or d corresponding to the desired direction to move. Anything else
            causes the player to do nothing.
        - :param frame_count:
            An int representing the current frame count of the game.
        - :return:
            None
        &#34;&#34;&#34;
        if key_pressed == &#34;w&#34; and self.rect.y &gt; 60:
            self.rect.y -= self.y_vel
            self.last_advancement = frame_count
        elif key_pressed == &#34;s&#34; and self.rect.y &lt; 800:
            self.rect.y += self.y_vel
        elif key_pressed == &#34;a&#34; and self.rect.x &gt; 20:
            self.rect.x -= self.x_vel
        elif key_pressed == &#34;d&#34; and self.rect.x &lt; 750:
            self.rect.x += self.x_vel
        else:
            return

    def find_distance_to_sprite(self, direction, sprites, player_lines=[]):
        &#34;&#34;&#34;
        Find the distance to the nearest sprite in a given direction. Calculates from the center point of the
        player to the sprite.rect.x or sprite.rect.y coordinate of the nearest sprite. Whether x or y is used depends
        on whether the direction being computed is vertical or horizontal - y for up or down and x for left or right.
        Parameter direction should be a string containing &#39;ahead&#39;, &#39;down&#39;, &#39;left&#39;, or &#39;right&#39; indicating the
        direction we wish to scan. Sprites should be a list of all the sprites that we want to &#39;see&#39;, which will be
        iterated over to scan for a sprite in the given direction. The player_lines parameter can be used to draw
        lines to the sprite for debugging, but defaults to empty.

        - :param direction:
            A string containing the direction to be searched. Should be &#34;ahead&#34;, &#34;down&#34;, &#34;left&#34;, or &#34;right&#34;. Anything else,
            and the function will return nothing.
        - :param sprites:
            A pygame Group object containing the sprites to be searched. Should be the Group object used for the AI to &#34;see&#34;
            other sprites.
        - :param player_lines:
            Optional debugging parameter. A list of tuples representing the endpoints of a line. This can be appended to
            in order to render the collision lines for debugging purposes.
        - :return:
            None
        &#34;&#34;&#34;
        # Player&#39;s current position will be the start point of a line that is used to check the nearest sprite
        player_x = self.rect.center[0]
        player_y = self.rect.center[1]
        player_pos = (player_x, player_y)

        if direction == &#34;ahead&#34;:
            distance_to_nearest = player_y

            # Set the endpoint of the line to the top of the screen, in the same x position as the player
            endpoint = (player_x, 0)

            # Iterate over the sprites we&#39;re concerned about to see if the line intersects
            for sprite in sprites:
                clipline = sprite.rect.clipline(player_pos, endpoint)

                # If the line intersects with the sprite in question, and the distance to it is shorter than current,
                # update current distance
                if clipline and player_y - sprite.rect.y &lt;= distance_to_nearest:
                    distance_to_nearest = player_y - sprite.rect.y

            return distance_to_nearest

        if direction == &#34;down&#34;:
            distance_to_nearest = Window.HEIGHT - player_y

            # Set the endpoint of the line to the bottom of the screen, in the same x position as the player
            endpoint = (player_x, Window.HEIGHT)

            # Iterate over the sprites we&#39;re concerned about to see if the line intersects
            for sprite in sprites:
                clipline = sprite.rect.clipline(player_pos, endpoint)

                # If the line intersects with the sprite in question, and the distance to it is shorter than current,
                # update current distance
                if clipline and sprite.rect.y - player_y &lt;= distance_to_nearest:
                    distance_to_nearest = sprite.rect.y - player_y

            return distance_to_nearest

        if direction == &#34;left&#34;:
            distance_to_nearest = player_x

            # Set the endpoint of the line to the left of the screen, in the same y position as the player
            endpoint = (0, player_y)

            # Iterate over the sprites we&#39;re concerned about to see if the line intersects
            for sprite in sprites.sprites():
                clipline = sprite.rect.clipline(player_pos, endpoint)

                # If the line intersects with the sprite in question, and the distance to it is shorter than current,
                # update current distance
                if clipline and player_x - (sprite.rect.x + sprite.rect.width) &lt;= distance_to_nearest:
                    distance_to_nearest = player_x - (sprite.rect.x + sprite.rect.width)

            return distance_to_nearest

        if direction == &#34;right&#34;:
            distance_to_nearest = Window.WIDTH - player_x

            # Set the endpoint of the line to the right of the screen, in the same y position as the player
            endpoint = (Window.WIDTH, player_y)

            # Iterate over the sprites we&#39;re concerned about to see if the line intersects
            for sprite in sprites.sprites():
                clipline = sprite.rect.clipline(player_pos, endpoint)

                # If the line intersects with the sprite in question, and the distance to it is shorter than current,
                # update current distance
                if clipline and sprite.rect.x - player_x &lt;= distance_to_nearest:
                    distance_to_nearest = sprite.rect.x - player_x

            return distance_to_nearest

    def find_sprite_in_next_lane(self, direction, sprites, player_lines=[]):
        &#34;&#34;&#34;
        Find the distance to the nearest sprite in the lane ahead or the lane behind the player. Returns a tuple
        containing the distance in the corresponding lane to the edge of the closest sprite on the left,
        and the closest sprite on the right, respectively. These distances will be measured from the x position of the
        center of the player rect.

        - :param direction:
            A string indicating whether the lane ahead is being searched or the lane behind. Should be &#34;ahead&#34; or &#34;down&#34;.
            Anything else, and the method won&#39;t return anything.
        - :param sprites:
            A pygame Group object containing the sprites to be searched. Should be the Group object used for the AI to &#34;see&#34;
            other sprites.
        - :param player_lines:
            Optional debugging parameter. A list of tuples representing the endpoints of a line. This can be appended to
            in order to render the collision lines for debugging purposes.
        - :return:
            None
        &#34;&#34;&#34;

        startpoint_x = self.rect.center[0]

        if direction == &#34;ahead&#34;:
            # If we want to use the lane ahead,
            # set the start point of the line to be one lane position ahead of the player
            startpoint_y = self.rect.center[1] - 64
            startpoint_pos = (startpoint_x, startpoint_y)

            # Initial distance is the distance to the left and right edges of the screen
            distance_to_left = startpoint_x
            distance_to_right = Window.WIDTH - startpoint_x

            # Set the endpoint of the left line and the right line to the edges of the screen
            left_endpoint = (0, startpoint_y)
            right_endpoint = (Window.WIDTH, startpoint_y)

            # Iterate over the sprites we&#39;re concerned about to see if the lines intersect
            for sprite in sprites.sprites():
                # Check the left side
                clipline = sprite.rect.clipline(startpoint_pos, left_endpoint)

                # If the line intersects with the sprite in question, and the distance to it is shorter than current,
                # update current distance
                if clipline and startpoint_x - (sprite.rect.x + sprite.rect.width) &lt;= distance_to_left:
                    distance_to_left = startpoint_x - (sprite.rect.x + sprite.rect.width)

                # Check the right side
                clipline = sprite.rect.clipline(startpoint_pos, right_endpoint)

                if clipline and sprite.rect.x - startpoint_x &lt;= distance_to_right:
                    distance_to_right = sprite.rect.x - startpoint_x

            # render lines for debugging
            # player_lines.append((startpoint_pos, (startpoint_x - distance_to_left, startpoint_y)))
            # player_lines.append((startpoint_pos, (startpoint_x + distance_to_right, startpoint_y)))
            return distance_to_left, distance_to_right

        if direction == &#34;down&#34;:
            # If we want to use the lane behind,
            # set the start point of the line to be one lane position behind the player
            startpoint_y = self.rect.center[1] + 64
            startpoint_pos = (startpoint_x, startpoint_y)

            # Initial distance is the distance to the left and right edges of the screen
            distance_to_left = startpoint_x
            distance_to_right = Window.WIDTH - startpoint_x

            # Set the endpoint of the left line and the right line to the edges of the screen
            left_endpoint = (0, startpoint_y)
            right_endpoint = (Window.WIDTH, startpoint_y)

            # Iterate over the sprites we&#39;re concerned about to see if the lines intersect
            for sprite in sprites.sprites():
                # Check the left side
                clipline = sprite.rect.clipline(startpoint_pos, left_endpoint)

                # If the line intersects with the sprite in question, and the distance to it is shorter than current,
                # update current distance
                if clipline and startpoint_x - (sprite.rect.x + sprite.rect.width) &lt;= distance_to_left:
                    distance_to_left = startpoint_x - (sprite.rect.x + sprite.rect.width)

                # Check the right side
                clipline = sprite.rect.clipline(startpoint_pos, right_endpoint)

                if clipline and sprite.rect.x - startpoint_x &lt;= distance_to_right:
                    distance_to_right = sprite.rect.x - startpoint_x

            return distance_to_left, distance_to_right</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygame.sprite.Sprite</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.Sprites.player.Player.find_distance_to_sprite"><code class="name flex">
<span>def <span class="ident">find_distance_to_sprite</span></span>(<span>self, direction, sprites, player_lines=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Find the distance to the nearest sprite in a given direction. Calculates from the center point of the
player to the sprite.rect.x or sprite.rect.y coordinate of the nearest sprite. Whether x or y is used depends
on whether the direction being computed is vertical or horizontal - y for up or down and x for left or right.
Parameter direction should be a string containing 'ahead', 'down', 'left', or 'right' indicating the
direction we wish to scan. Sprites should be a list of all the sprites that we want to 'see', which will be
iterated over to scan for a sprite in the given direction. The player_lines parameter can be used to draw
lines to the sprite for debugging, but defaults to empty.</p>
<ul>
<li>:param direction:
A string containing the direction to be searched. Should be "ahead", "down", "left", or "right". Anything else,
and the function will return nothing.</li>
<li>:param sprites:
A pygame Group object containing the sprites to be searched. Should be the Group object used for the AI to "see"
other sprites.</li>
<li>:param player_lines:
Optional debugging parameter. A list of tuples representing the endpoints of a line. This can be appended to
in order to render the collision lines for debugging purposes.</li>
<li>:return:
None</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_distance_to_sprite(self, direction, sprites, player_lines=[]):
    &#34;&#34;&#34;
    Find the distance to the nearest sprite in a given direction. Calculates from the center point of the
    player to the sprite.rect.x or sprite.rect.y coordinate of the nearest sprite. Whether x or y is used depends
    on whether the direction being computed is vertical or horizontal - y for up or down and x for left or right.
    Parameter direction should be a string containing &#39;ahead&#39;, &#39;down&#39;, &#39;left&#39;, or &#39;right&#39; indicating the
    direction we wish to scan. Sprites should be a list of all the sprites that we want to &#39;see&#39;, which will be
    iterated over to scan for a sprite in the given direction. The player_lines parameter can be used to draw
    lines to the sprite for debugging, but defaults to empty.

    - :param direction:
        A string containing the direction to be searched. Should be &#34;ahead&#34;, &#34;down&#34;, &#34;left&#34;, or &#34;right&#34;. Anything else,
        and the function will return nothing.
    - :param sprites:
        A pygame Group object containing the sprites to be searched. Should be the Group object used for the AI to &#34;see&#34;
        other sprites.
    - :param player_lines:
        Optional debugging parameter. A list of tuples representing the endpoints of a line. This can be appended to
        in order to render the collision lines for debugging purposes.
    - :return:
        None
    &#34;&#34;&#34;
    # Player&#39;s current position will be the start point of a line that is used to check the nearest sprite
    player_x = self.rect.center[0]
    player_y = self.rect.center[1]
    player_pos = (player_x, player_y)

    if direction == &#34;ahead&#34;:
        distance_to_nearest = player_y

        # Set the endpoint of the line to the top of the screen, in the same x position as the player
        endpoint = (player_x, 0)

        # Iterate over the sprites we&#39;re concerned about to see if the line intersects
        for sprite in sprites:
            clipline = sprite.rect.clipline(player_pos, endpoint)

            # If the line intersects with the sprite in question, and the distance to it is shorter than current,
            # update current distance
            if clipline and player_y - sprite.rect.y &lt;= distance_to_nearest:
                distance_to_nearest = player_y - sprite.rect.y

        return distance_to_nearest

    if direction == &#34;down&#34;:
        distance_to_nearest = Window.HEIGHT - player_y

        # Set the endpoint of the line to the bottom of the screen, in the same x position as the player
        endpoint = (player_x, Window.HEIGHT)

        # Iterate over the sprites we&#39;re concerned about to see if the line intersects
        for sprite in sprites:
            clipline = sprite.rect.clipline(player_pos, endpoint)

            # If the line intersects with the sprite in question, and the distance to it is shorter than current,
            # update current distance
            if clipline and sprite.rect.y - player_y &lt;= distance_to_nearest:
                distance_to_nearest = sprite.rect.y - player_y

        return distance_to_nearest

    if direction == &#34;left&#34;:
        distance_to_nearest = player_x

        # Set the endpoint of the line to the left of the screen, in the same y position as the player
        endpoint = (0, player_y)

        # Iterate over the sprites we&#39;re concerned about to see if the line intersects
        for sprite in sprites.sprites():
            clipline = sprite.rect.clipline(player_pos, endpoint)

            # If the line intersects with the sprite in question, and the distance to it is shorter than current,
            # update current distance
            if clipline and player_x - (sprite.rect.x + sprite.rect.width) &lt;= distance_to_nearest:
                distance_to_nearest = player_x - (sprite.rect.x + sprite.rect.width)

        return distance_to_nearest

    if direction == &#34;right&#34;:
        distance_to_nearest = Window.WIDTH - player_x

        # Set the endpoint of the line to the right of the screen, in the same y position as the player
        endpoint = (Window.WIDTH, player_y)

        # Iterate over the sprites we&#39;re concerned about to see if the line intersects
        for sprite in sprites.sprites():
            clipline = sprite.rect.clipline(player_pos, endpoint)

            # If the line intersects with the sprite in question, and the distance to it is shorter than current,
            # update current distance
            if clipline and sprite.rect.x - player_x &lt;= distance_to_nearest:
                distance_to_nearest = sprite.rect.x - player_x

        return distance_to_nearest</code></pre>
</details>
</dd>
<dt id="src.Sprites.player.Player.find_sprite_in_next_lane"><code class="name flex">
<span>def <span class="ident">find_sprite_in_next_lane</span></span>(<span>self, direction, sprites, player_lines=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Find the distance to the nearest sprite in the lane ahead or the lane behind the player. Returns a tuple
containing the distance in the corresponding lane to the edge of the closest sprite on the left,
and the closest sprite on the right, respectively. These distances will be measured from the x position of the
center of the player rect.</p>
<ul>
<li>:param direction:
A string indicating whether the lane ahead is being searched or the lane behind. Should be "ahead" or "down".
Anything else, and the method won't return anything.</li>
<li>:param sprites:
A pygame Group object containing the sprites to be searched. Should be the Group object used for the AI to "see"
other sprites.</li>
<li>:param player_lines:
Optional debugging parameter. A list of tuples representing the endpoints of a line. This can be appended to
in order to render the collision lines for debugging purposes.</li>
<li>:return:
None</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_sprite_in_next_lane(self, direction, sprites, player_lines=[]):
    &#34;&#34;&#34;
    Find the distance to the nearest sprite in the lane ahead or the lane behind the player. Returns a tuple
    containing the distance in the corresponding lane to the edge of the closest sprite on the left,
    and the closest sprite on the right, respectively. These distances will be measured from the x position of the
    center of the player rect.

    - :param direction:
        A string indicating whether the lane ahead is being searched or the lane behind. Should be &#34;ahead&#34; or &#34;down&#34;.
        Anything else, and the method won&#39;t return anything.
    - :param sprites:
        A pygame Group object containing the sprites to be searched. Should be the Group object used for the AI to &#34;see&#34;
        other sprites.
    - :param player_lines:
        Optional debugging parameter. A list of tuples representing the endpoints of a line. This can be appended to
        in order to render the collision lines for debugging purposes.
    - :return:
        None
    &#34;&#34;&#34;

    startpoint_x = self.rect.center[0]

    if direction == &#34;ahead&#34;:
        # If we want to use the lane ahead,
        # set the start point of the line to be one lane position ahead of the player
        startpoint_y = self.rect.center[1] - 64
        startpoint_pos = (startpoint_x, startpoint_y)

        # Initial distance is the distance to the left and right edges of the screen
        distance_to_left = startpoint_x
        distance_to_right = Window.WIDTH - startpoint_x

        # Set the endpoint of the left line and the right line to the edges of the screen
        left_endpoint = (0, startpoint_y)
        right_endpoint = (Window.WIDTH, startpoint_y)

        # Iterate over the sprites we&#39;re concerned about to see if the lines intersect
        for sprite in sprites.sprites():
            # Check the left side
            clipline = sprite.rect.clipline(startpoint_pos, left_endpoint)

            # If the line intersects with the sprite in question, and the distance to it is shorter than current,
            # update current distance
            if clipline and startpoint_x - (sprite.rect.x + sprite.rect.width) &lt;= distance_to_left:
                distance_to_left = startpoint_x - (sprite.rect.x + sprite.rect.width)

            # Check the right side
            clipline = sprite.rect.clipline(startpoint_pos, right_endpoint)

            if clipline and sprite.rect.x - startpoint_x &lt;= distance_to_right:
                distance_to_right = sprite.rect.x - startpoint_x

        # render lines for debugging
        # player_lines.append((startpoint_pos, (startpoint_x - distance_to_left, startpoint_y)))
        # player_lines.append((startpoint_pos, (startpoint_x + distance_to_right, startpoint_y)))
        return distance_to_left, distance_to_right

    if direction == &#34;down&#34;:
        # If we want to use the lane behind,
        # set the start point of the line to be one lane position behind the player
        startpoint_y = self.rect.center[1] + 64
        startpoint_pos = (startpoint_x, startpoint_y)

        # Initial distance is the distance to the left and right edges of the screen
        distance_to_left = startpoint_x
        distance_to_right = Window.WIDTH - startpoint_x

        # Set the endpoint of the left line and the right line to the edges of the screen
        left_endpoint = (0, startpoint_y)
        right_endpoint = (Window.WIDTH, startpoint_y)

        # Iterate over the sprites we&#39;re concerned about to see if the lines intersect
        for sprite in sprites.sprites():
            # Check the left side
            clipline = sprite.rect.clipline(startpoint_pos, left_endpoint)

            # If the line intersects with the sprite in question, and the distance to it is shorter than current,
            # update current distance
            if clipline and startpoint_x - (sprite.rect.x + sprite.rect.width) &lt;= distance_to_left:
                distance_to_left = startpoint_x - (sprite.rect.x + sprite.rect.width)

            # Check the right side
            clipline = sprite.rect.clipline(startpoint_pos, right_endpoint)

            if clipline and sprite.rect.x - startpoint_x &lt;= distance_to_right:
                distance_to_right = sprite.rect.x - startpoint_x

        return distance_to_left, distance_to_right</code></pre>
</details>
</dd>
<dt id="src.Sprites.player.Player.kill"><code class="name flex">
<span>def <span class="ident">kill</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the player dies. Returns him home, and subtracts a life from his life_count.</p>
<ul>
<li>:return:
None</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kill(self):
    &#34;&#34;&#34;
    Called when the player dies. Returns him home, and subtracts a life from his life_count.

    - :return:
        None
    &#34;&#34;&#34;
    self.return_home()
    self.lives_left -= 1</code></pre>
</details>
</dd>
<dt id="src.Sprites.player.Player.move"><code class="name flex">
<span>def <span class="ident">move</span></span>(<span>self, key_pressed, frame_count)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the AI computes an output layer. Takes a string containing w, a, s, or d, and moves the player
in the corresponding direction. If any other input is passed, the player won't move at all.</p>
<ul>
<li>:param key_pressed:
A string that should contain w, a, s, or d corresponding to the desired direction to move. Anything else
causes the player to do nothing.</li>
<li>:param frame_count:
An int representing the current frame count of the game.</li>
<li>:return:
None</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move(self, key_pressed, frame_count):
    &#34;&#34;&#34;
    Called when the AI computes an output layer. Takes a string containing w, a, s, or d, and moves the player
    in the corresponding direction. If any other input is passed, the player won&#39;t move at all.

    - :param key_pressed:
        A string that should contain w, a, s, or d corresponding to the desired direction to move. Anything else
        causes the player to do nothing.
    - :param frame_count:
        An int representing the current frame count of the game.
    - :return:
        None
    &#34;&#34;&#34;
    if key_pressed == &#34;w&#34; and self.rect.y &gt; 60:
        self.rect.y -= self.y_vel
        self.last_advancement = frame_count
    elif key_pressed == &#34;s&#34; and self.rect.y &lt; 800:
        self.rect.y += self.y_vel
    elif key_pressed == &#34;a&#34; and self.rect.x &gt; 20:
        self.rect.x -= self.x_vel
    elif key_pressed == &#34;d&#34; and self.rect.x &lt; 750:
        self.rect.x += self.x_vel
    else:
        return</code></pre>
</details>
</dd>
<dt id="src.Sprites.player.Player.nest"><code class="name flex">
<span>def <span class="ident">nest</span></span>(<span>self, timer, nest)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the player reaches a nest to return him home and handle the score increase.</p>
<ul>
<li>:param timer:
An int representing the current timer value.</li>
<li>:param nest:
A Nest object, should be the nest that the player reached to trigger this method to be called</li>
<li>:return:
None</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nest(self, timer, nest):
    &#34;&#34;&#34;
    Called when the player reaches a nest to return him home and handle the score increase.

    - :param timer:
        An int representing the current timer value.
    - :param nest:
        A Nest object, should be the nest that the player reached to trigger this method to be called
    - :return:
        None
    &#34;&#34;&#34;
    if self.disabled_nests.has(nest):
        self.kill()
    else:
        self.return_home()
        self.farthest_distance = 813
        self.score += (50 + 2*timer)
        # pygame.time.set_timer(pygame.USEREVENT, 0)  # Reset clock tick so we aren&#39;t still using the old clock
        # pygame.time.set_timer(pygame.USEREVENT, 1000)
        # timer = 30
    if not self.disabled_nests.has(nest):
        self.disabled_nests.add(nest)</code></pre>
</details>
</dd>
<dt id="src.Sprites.player.Player.return_home"><code class="name flex">
<span>def <span class="ident">return_home</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the player to the starting position, with the starting sprite orientation.</p>
<ul>
<li>:return:
None</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def return_home(self):
    &#34;&#34;&#34;
    Return the player to the starting position, with the starting sprite orientation.

    - :return:
        None
    &#34;&#34;&#34;
    self.rect.x = Window.WIN.get_width() / 2
    self.rect.y = Window.WIN.get_height() - self.rect.height - 11
    self.index = 0
    self.image = self.images[self.index]
    self.direction = &#34;up&#34;
    up_image = AssetDictionary.get_asset(&#34;frog&#34;)
    up_image2 = AssetDictionary.get_asset(&#34;frog_jumping&#34;)
    self.images = [up_image, up_image2]</code></pre>
</details>
</dd>
<dt id="src.Sprites.player.Player.set_score"><code class="name flex">
<span>def <span class="ident">set_score</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called on every frame. Handles the logic determining when the player should receive more points for moving.</p>
<ul>
<li>:return:
None</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_score(self):
    &#34;&#34;&#34;
    Called on every frame. Handles the logic determining when the player should receive more points for moving.

    - :return:
        None
    &#34;&#34;&#34;
    self.score += 0.01  # Reward the AI a little bit for staying alive another frame

    # If the current position is a new farthest distance, increase the score
    if self.farthest_distance &gt; self.rect.y &gt; 110:
        self.farthest_distance = self.rect.y
        self.score += 10
        if self.score &gt; 60 and self.rect.y &gt;= 109:
            self.score += 10</code></pre>
</details>
</dd>
<dt id="src.Sprites.player.Player.win_game"><code class="name flex">
<span>def <span class="ident">win_game</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the player reaches all nests and has won the game. Adds 2000 to the player's score and removes them
from all groups they are in so they will no longer be rendered.</p>
<ul>
<li>:return:
None</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def win_game(self):
    &#34;&#34;&#34;
    Called when the player reaches all nests and has won the game. Adds 2000 to the player&#39;s score and removes them
    from all groups they are in so they will no longer be rendered.

    - :return:
        None
    &#34;&#34;&#34;
    self.score += 2000
    for group in self.groups():
        self.remove(group)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.Sprites" href="index.html">src.Sprites</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.Sprites.player.Player" href="#src.Sprites.player.Player">Player</a></code></h4>
<ul class="">
<li><code><a title="src.Sprites.player.Player.find_distance_to_sprite" href="#src.Sprites.player.Player.find_distance_to_sprite">find_distance_to_sprite</a></code></li>
<li><code><a title="src.Sprites.player.Player.find_sprite_in_next_lane" href="#src.Sprites.player.Player.find_sprite_in_next_lane">find_sprite_in_next_lane</a></code></li>
<li><code><a title="src.Sprites.player.Player.kill" href="#src.Sprites.player.Player.kill">kill</a></code></li>
<li><code><a title="src.Sprites.player.Player.move" href="#src.Sprites.player.Player.move">move</a></code></li>
<li><code><a title="src.Sprites.player.Player.nest" href="#src.Sprites.player.Player.nest">nest</a></code></li>
<li><code><a title="src.Sprites.player.Player.return_home" href="#src.Sprites.player.Player.return_home">return_home</a></code></li>
<li><code><a title="src.Sprites.player.Player.set_score" href="#src.Sprites.player.Player.set_score">set_score</a></code></li>
<li><code><a title="src.Sprites.player.Player.win_game" href="#src.Sprites.player.Player.win_game">win_game</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>